rm(list = ls())  
options(stringsAsFactors = F)
setwd('C:\\Users\\dell\\Desktop\\IMET1')
library('DESeq2')

#2. Load counts.txt file generated by featureCounts in RStudio
database <- read.table("ps.txt",row.names = 1 ,header=T,sep = '\t')  # If there are issues with character encoding, can use fileEncoding="UTF-16LE"

#3. Set up sample information - the first 2 samples are proliferation group, the other 2 samples are senescence group
condition <- factor(c(rep("P",2), rep("S",2)))    
coldata <- data.frame(row.names = colnames(database), condition)
coldata    # Display coldata values, sample information is critical for correct analysis

#4. Create dds object: combines the count matrix (database) and sample information (coldata)
dds <- DESeqDataSetFromMatrix(countData=database, colData=coldata, design=~condition)

#5. Filter low expression data, an important step. Choose threshold based on your data. In my case, keeping genes with at least 10 reads in at least 2 samples
keep <- rowSums(counts(dds) >= 10) >= 2  # Filter out low expressed genes, requiring at least 10 reads in at least 2 samples
dds <- dds[keep, ] 

#6. Check sample clustering (prepare for vst normalization---hclust)
BiocManager::install('factoextra') 
library('factoextra')          # Load the factoextra package
vsd <- vst(dds,blind = TRUE)    # Using blind=TRUE to avoid considering design information during transformation
sampleDists <- dist(t(assay(vsd))) 
res1 <- hcut(sampleDists, k = 2, stand = FALSE,hc_method ="average" ) 
fviz_dend(res1,
          rect_fill = T,
          # Font size
          cex = 1,
          # Colored labels
          color_labels_by_k=T,
          # Horizontal layout
          horiz=T)

#7. Principal component analysis (PCA) - another clustering approach
rld <- vst(dds, blind=FALSE)     # vst() is more efficient than rlog(), and faster
plotPCA(rld, intgroup="condition",ntop=500)

#8. Run DESeq analysis on the prepared dds object
dds1 <- DESeq(dds)    # Data standardization, key step!
resultsNames(dds1)    # View result names
dds1$condition        # By default the second condition is compared to the first
res <- results(dds1)  # Critical step!
summary(res)          # Summary of results, p-value default is 0.1

#9. Extract all analysis results
table(res$padj < 0.05)        # How many differentially expressed genes with adjusted p-value < 0.05
res <- res[order(res$padj),]  # Sort by adjusted p-value
resdata <- merge(as.data.frame(res), as.data.frame(counts(dds1, normalized=TRUE)),by="row.names",sort=FALSE)
write.csv(resdata,file = "s_p.csv")   # Result file containing all genes

#10. Extract differentially expressed genes with thresholds
diff_gene_deseq2 <-subset(res, padj < 0.05 & (log2FoldChange > 1 | log2FoldChange < -1))   # Can also be written as: diff_gene_deseq2 <- subset(res, padj < 0.05 & abs(log2FoldChange) > 1)
write.csv(diff_gene_deseq2,file= "diff_gene_s_p.csv")  # Output file for differentially expressed genes

# Separate up and down regulated genes
up_DEG <- subset(res, padj < 0.05 & log2FoldChange > 1)
down_DEG <- subset(res, padj < 0.05 & log2FoldChange < -1)
write.csv(up_DEG, "up-gene.csv")      # Result file for up-regulated genes
write.csv(down_DEG, "down-gene.csv")  # Result file for down-regulated genes

# Count the number of differentially expressed genes, up and down regulated (optional step)
dim(diff_gene_deseq2)  
dim(up_DEG)
dim(down_DEG)